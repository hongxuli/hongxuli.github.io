<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hongxuli.github.io</id>
    <title>Hongxu Li</title>
    <updated>2020-03-18T21:15:58.215Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hongxuli.github.io"/>
    <link rel="self" href="https://hongxuli.github.io/atom.xml"/>
    <subtitle>Stay hungry, stay foolish</subtitle>
    <logo>https://hongxuli.github.io/images/avatar.png</logo>
    <icon>https://hongxuli.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Hongxu Li</rights>
    <entry>
        <title type="html"><![CDATA[event delegation]]></title>
        <id>https://hongxuli.github.io/post/event-delegation/</id>
        <link href="https://hongxuli.github.io/post/event-delegation/">
        </link>
        <updated>2020-03-18T07:29:23.000Z</updated>
        <content type="html"><![CDATA[<p>Event delegation is a technique involving adding event listener to a parent element instead of descendant elements</p>
<p>Due to the bubbling in DOM, the listener will fire whenever the event is triggerd on the descendant elements.</p>
<p>benefits:<br>
- save memory, because there is only one listener in the parent element. you    don't need to add event listener for each descendants elements<br>
- you dont need to unbind/bind the listener form the descendant elements which need to be deleted/added</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Amd vs commonJs]]></title>
        <id>https://hongxuli.github.io/post/amd-vs-commonjs/</id>
        <link href="https://hongxuli.github.io/post/amd-vs-commonjs/">
        </link>
        <updated>2020-03-18T07:21:43.000Z</updated>
        <content type="html"><![CDATA[<p>Both are ways to implement module system in JS<br>
They were come up since ES2015<br>
CommonJs is synchronous , which is desgin for sever side<br>
AMD   asychornous module definition, which is better to use in browser</p>
<p>Since we usually build our js file into a bundle, we would't benefit from the async loading.<br>
we can always use transpilers to convert our code.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[closure]]></title>
        <id>https://hongxuli.github.io/post/closure/</id>
        <link href="https://hongxuli.github.io/post/closure/">
        </link>
        <updated>2020-03-17T05:39:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="what-is-closure">##what is closure</h2>
<p>A closure is the <em>combination</em> of <strong>a function</strong> and the <strong>lexical environment</strong> whithin which that function was declard.<br>
lexical refer the variables are declared within the lexical scoping.<br>
closures are function that have access to outer(enclosing)function's variables-scope chain even after the outer function has returned.</p>
<p>####why would you use it</p>
<ul>
<li>Data privacy/ emulating private methods with closuers. commonly used in the module pattern</li>
<li>Partial applications or currying</li>
</ul>
<h2 id="in-for-loop">###in for loop</h2>
<p><code>for(var i=0;i&lt;10;i++){ setTimeout(function(){ console.log(i)//10个10 },1000) }</code></p>
<p>use closure   or   let<br>
`for(var i=0;i&lt;10;i++){<br>
((j)=&gt;{<br>
setTimeout(function(){<br>
console.log(j)//1-10<br>
},1000)})(i)</p>
<p>}`</p>
<h2 id="implement-in-debounce-function">###implement in debounce function</h2>
<p><code>window.onresize = function(){ console.log('onresize')// trigger it only once }</code></p>
<p>without clouser<br>
`<br>
window.onresize = function(){<br>
debounce(fn,1000)<br>
}<br>
var fn = function(){    console.log('fn')<br>
}<br>
var time = ''<br>
function debounce(fn,timeLong){<br>
if(time){<br>
clearTimeout(time)<br>
time = ''<br>
}</p>
<pre><code>    time =setTimeout(function(){
     fn()
    },timeLong)
</code></pre>
<p>}<br>
<code>with closure</code><br>
window.onresize = debounce(fn,500)</p>
<p>function debounce(fn){<br>
var timer = null<br>
return function(){<br>
if(timer){     //timer第一次执行后会保存在内存里 永远都是执行器 直到最后被触发<br>
clearTimeout(timer)<br>
timer = null<br>
}<br>
timer = setTimeout(function(){</p>
<pre><code>        fn()
    },1000)
    
    }
</code></pre>
<p>}<br>
var fn = function(){</p>
<pre><code>console.log('fn')
</code></pre>
<p>}</p>
<p>`</p>
]]></content>
    </entry>
</feed>